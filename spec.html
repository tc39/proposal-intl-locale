<!doctype html>
<meta charset="utf8">
<pre class=metadata>
title: Intl.Locale
stage: 3
contributors: Mozilla, Ecma International
</pre>
<emu-clause id="locale-objects">
  <h1>Locale Objects</h1>

  <emu-clause id="sec-intl-locale-constructor">
    <h1>The Intl.Locale Constructor</h1>

    <p>
      The Locale constructor is a standard built-in property of the Intl object.
    </p>

    <emu-clause id="sec-apply-options-to-tag" aoid=ApplyOptionsToTag>
      <h1>ApplyOptionsToTag( _tag_, _opt_ )</h1>
      <p>
        The following algorithm refers to <a href="https://tools.ietf.org/html/rfc5646#section-2.1">RFC 5646's Language-Tag grammar</a>.
      </p>

      <emu-alg>
        1. Assert: Type(_tag_) is String.
        1. Assert: IsStructurallyValidLanguageTag(_tag_) is *true*.
        1. If _opt_ has a [[Language]] field, let _language_ be _opt_.[[Language]].
        1. Otherwise, let _language_ be *undefined*.
        1. If _opt_ has a [[Script]] field, let _script_ be _opt_.[[Script]].
        1. Otherwise, let _script_ be *undefined*.
        1. If _opt_ has a [[Region]] field, let _region_ be _opt_.[[Region]].
        1. Otherwise, let _region_ be *undefined*.
        1. If _tag_ matches neither the `privateuse` nor the `grandfathered` production, then
          1. Assert: _tag_ matches the `langtag` production.
          1. If _language_ is not *undefined*, then
            1. Set _tag_ to _tag_ with the substring corresponding to the `language` production replaced by the string _language_.
          1. If _script_ is not *undefined*, then
            1. If _tag_ does not contain a `script` production, then
              1. Set _tag_ to the concatenation of the `language` production of _tag_, `"-"`, _script_, and the rest of _tag_.
            1. Else,
              1. Set _tag_ to _tag_ with the substring corresponding to the `script` production replaced by the string _script_.
          1. If _region_ is not *undefined*, then
            1. If _tag_ does not contain a `region` production, then
              1. Set _tag_ to the concatenation of the `language` production of _tag_, the substring corresponding to the `"-" script` production if present, `"-"`, _region_, and the rest of _tag_.
            1. Else,
              1. Set _tag_ to _tag_ with the substring corresponding to the `region` production replaced by the string _region_.
        1. Return CanonicalizeLanguageTag(_tag_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-apply-unicode-extension-to-tag" aoid=ApplyUnicodeExtensionToTag>
      <h1>ApplyUnicodeExtensionToTag( _tag_, _options_, _relevantExtensionKeys_ )</h1>
      <p>
        The following algorithm refers to <a href="https://tools.ietf.org/html/rfc5646#section-2.1">RFC 5646's Language-Tag grammar</a>.
      </p>

      <emu-alg>
        1. Assert: Type(_tag_) is String.
        1. If _tag_ matches the `privateuse` or the `grandfathered` production, then
          1. Let _result_ be a new Record.
          1. Repeat for each element _key_ of _relevantExtensionKeys_ in List order,
            1. Set result.[[<_key_>]] to *undefined*.
          1. Set _result_.[[locale]] to _tag_.
          1. Return _result_.
        1. Assert: _tag_ matches the `langtag` production.
        1. If _tag_ contains a substring that is a Unicode locale extension sequence, then
          1. Let _extension_ be the String value consisting of the first substring of _tag_ that is a Unicode locale extension sequence.
          1. Let _components_ be ! UnicodeExtensionComponents(_extension_).
          1. Let _attributes_ be _components_.[[Attributes]].
          1. Let _keywords_ be _components_.[[Keywords]].
        1. Else,
          1. Let _attributes_ be the empty List.
          1. Let _keywords_ be the empty List.
        1. Let _result_ be a new Record.
        1. Repeat for each element _key_ of _relevantExtensionKeys_ in List order,
          1. Let _value_ be *undefined*.
          1. If _keywords_ contains an element whose [[Key]] is the same as _key_, then
            1. Let _entry_ be the element of _keywords_ whose [[Key]] is the same as _key_.
            1. Let _value_ be _entry_.[[Value]].
          1. Else
            1. Let _entry_ be ~empty~.
          1. Assert: _options_ has a field [[<_key_>]].
          1. Let _optionsValue_ be _options_.[[<_key_>]].
          1. If _optionsValue_ is not *undefined*, then
            1. Assert: Type(_optionsValue_) is String.
            1. Let _value_ be _optionsValue_.
            1. If _entry_ is not ~empty~, then
              1. Set _entry_.[[Value]] to _value_.
            1. Else,
              1. Append the Record{[[Key]]: _key_, [[Value]]: _value_} to _keywords_.
          1. Set _result_.[[<_key_>]] to _value_.
        1. Let _locale_ be the String value that is _tag_ with all Unicode locale extension sequences removed.
        1. Let _newExtension_ be ! CanonicalizeUnicodeExtension(_attributes_, _keywords_).
        1. If _newExtension_ is not the empty String, then
          1. Let _locale_ be ! InsertUnicodeExtension(_locale_, _newExtension_).
        1. Set _result_.[[locale]] to _locale_.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-unicode-extension-components" aoid=UnicodeExtensionComponents>
      <h1>UnicodeExtensionComponents( _extension_ )</h1>
      <p>
        The UnicodeExtensionComponents abstract operation returns the attributes and keywords from _extension_, which must be a Unicode locale extension sequence. If an attribute or a keyword occurs multiple times in _extension_, only the first occurence is returned. The following steps are taken:
      </p>

      <emu-alg>
        1. Let _attributes_ be the empty List.
        1. Let _keywords_ be the empty List.
        1. Let _isKeyword_ be *false*.
        1. Let _size_ be the number of elements in _extension_.
        1. Let _k_ be 3.
        1. Repeat, while _k_ &lt; _size_
          1. Let _e_ be ! Call(%StringProto_indexOf%, _extension_, « `"-"`, _k_ »).
          1. If _e_ = -1, let _len_ be _size_ - _k_; else let _len_ be _e_ - _k_.
          1. Let _subtag_ the String value equal to the substring of _extension_ consisting of the code units at indices _k_ (inclusive) through _k_ + _len_ (exclusive).
          1. If _isKeyword_ is *false*, then
            1. If _len_ &ne; 2 and _subtag_ is not an element of _attributes_, then
              1. Append _subtag_ to _attributes_.
          1. Else,
            1. If _len_ = 2, then
              1. If _keywords_ does not contain an element whose [[Key]] is the same as _key_, then
                1. Append the Record{[[Key]]: _key_, [[Value]]: _value_} to _keywords_.
            1. Else,
              1. If _value_ is not the empty String, then
                1. Let _value_ be the string-concatenation of _value_ and `"-"`.
              1. Let _value_ be the string-concatenation of _value_ and _subtag_.
          1. If _len_ = 2, then
            1. Let _isKeyword_ be *true*.
            1. Let _key_ be _subtag_.
            1. Let _value_ be the empty String.
          1. Let _k_ be _k_ + _len_ + 1.
        1. If _isKeyword_ is *true*, then
          1. If _keywords_ does not contain an element whose [[Key]] is the same as _key_, then
            1. Append the Record{[[Key]]: _key_, [[Value]]: _value_} to _keywords_.
        1. Return the Record{[[Attributes]]: _attributes_, [[Keywords]]: _keywords_}.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-canonicalize-unicode-extension" aoid=CanonicalizeUnicodeExtension>
      <h1>CanonicalizeUnicodeExtension( _attributes_, _keywords_ )</h1>
      <p>
        The CanonicalizeUnicodeExtension abstract operation creates the canonical Unicode locale extension sequence from _attributes_, which must be a List of String values, and _keywords_, which must be a List of Record values. The empty String is returned if both arguments are empty Lists. The following steps are taken:
      </p>

      <emu-alg>
        1. If _attributes_ is empty and _keywords_ is empty, then
          1. Return the empty String.
        1. Let _sortedAttributes_ be a new List containing the same values as the list _attributes_ where the values are ordered as if an Array of the same values had been sorted using `Array.prototype.sort` using *undefined* as _comparefn_.
        1. Let _fullKeywords_ be the empty List.
        1. Repeat for each element _entry_ of _keywords_ in List order,
          1. Let _keyword_ be _entry_.[[Key]].
          1. If _entry_.[[Value]] is not the empty String, then
            1. Let _keyword_ be the string-concatenation of _keyword_, `"-"`, and _entry_.[[Value]].
          1. Append _keyword_ to _fullKeywords_.
        1. Let _sortedKeywords_ be a new List containing the same values as the list _fullKeywords_ where the values are ordered as if an Array of the same values had been sorted using `Array.prototype.sort` using *undefined* as _comparefn_.
        1. Let _extension_ be `"-u"`.
        1. Repeat for each element _attribute_ of _sortedAttributes_ in List order,
          1. Let _extension_ be the string-concatenation of _extension_, `"-"`, and _attribute_.
        1. Repeat for each element _keyword_ of _sortedKeywords_ in List order,
          1. Let _extension_ be the string-concatenation of _extension_, `"-"`, and _keyword_.
        1. Return _extension_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-insert-unicode-extension" aoid=InsertUnicodeExtension>
      <h1>InsertUnicodeExtension( _locale_, _extension_ )</h1>
      <p>
        The InsertUnicodeExtension abstract operation inserts _extension_, which must be a Unicode locale extension sequence, into _locale_, which must be a String value with a structurally valid and canonicalized BCP 47 language tag. The following steps are taken:
      </p>

      <emu-alg>
        1. Assert: _locale_ does not contain a substring that is a Unicode locale extension sequence.
        1. Assert: _extension_ is a Unicode extension sequence.
        1. Let _privateIndex_ be ! Call(%StringProto_indexOf%, _locale_, &laquo; `"-x-"` &raquo;).
        1. If _privateIndex_ = -1, then
          1. Let _locale_ be the concatenation of _locale_ and _extension_.
        1. Else,
          1. Let _preExtension_ be the substring of _locale_ from position 0, inclusive, to position _privateIndex_, exclusive.
          1. Let _postExtension_ be the substring of _locale_ from position _privateIndex_ to the end of the string.
          1. Let _locale_ be the string-concatenation of _preExtension_, _extension_, and _postExtension_.
        1. Assert: ! IsStructurallyValidLanguageTag(_locale_) is *true*.
        1. Return ! CanonicalizeLanguageTag(_locale_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-create-locale" aoid="CreateLocale">
      <h1>CreateLocale ( _tag_ [, _opt_ [, _proto_ ] ] )</h1>
      <emu-alg>
        1. If _opt_ is not provided, let _opt_ be a new Record.
        1. If _proto_ is not provided, let _proto_ be *%LocalePrototype%*.
        1. Let _relevantExtensionKeys_ be %Locale%.[[RelevantExtensionKeys]].
        1. Let _internalSlotsList_ be &laquo; [[InitializedLocale]], [[Locale]], [[BaseName]], [[ca]], [[co]], [[hc]], [[nu]] &raquo;.
        1. If _relevantExtensionKeys_ contains `"kf"`, then
          1. Append [[kf]] as the last element of _internalSlotsList_.
        1. If _relevantExtensionKeys_ contains `"kn"`, then
          1. Append [[kn]] as the last element of _internalSlotsList_.
        1. Let _locale_ be ! ObjectCreate(_proto_, _internalSlotsList_).
        1. If IsStructurallyValidLanguageTag(_tag_) is *false*, throw a *RangeError* exception.
        1. Set _tag_ to ! ApplyOptionsToTag(_tag_, _opt_).
        1. Let _r_ be ! ApplyUnicodeExtensionToTag(_tag_, _opt_, _relevantExtensionKeys_).
        1. Set _locale_.[[Locale]] to _r_.[[locale]].
        1. If _r_.[[Locale]] does not match the `langtag` production,
          1. Set _locale_.[[BaseName]] to _r_.[[locale]].
        1. Otherwise,
          1. Set _locale_.[[BaseName]] to the substring of _r_.[[locale]] corresponding to the `language ["-" script] ["-" region] *("-" variant) ["-" privateuse]` subsequence of the `langtag` grammar.
        1. Set _locale_.[[ca]] to _r_.[[ca]].
        1. Set _locale_.[[co]] to _r_.[[co]].
        1. Set _locale_.[[hc]] to _r_.[[hc]].
        1. If _relevantExtensionKeys_ contains `"kf"`, then
          1. Set _locale_.[[kf]] to _r_.[[kf]].
        1. If _relevantExtensionKeys_ contains `"kn"`, then
          1. Set _locale_.[[kn]] to _r_.[[kn]].
        1. Set _locale_.[[nu]] to _r_.[[nu]].
        1. Return _locale_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-Intl.Locale">
      <h1>Intl.Locale ( _tag_ [ , _options_ ] )</h1>

      <p>
        The following algorithm refers to <a href="https://tools.ietf.org/html/rfc5646#section-2.1">RFC 5646's Language-Tag grammar</a>.

        When the *Intl.Locale* function is called with an argument _tag_ and an optional argument _options_, the following steps are taken:
      </p>

      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Let _proto_ be ? GetProtypeFromConstructor(NewTarget, `"%LocalePrototype%"`).
        1. If Type(_tag_) is not String or Object, throw a *TypeError* exception.
        1. If Type(_tag_) is Object and _tag_ has an [[InitializedLocale]] internal slot, then
          1. Let _tag_ be _tag_.[[Locale]].
        1. Else,
          1. Let _tag_ be ? ToString(_tag_).
        1. If _options_ is *undefined*, then
          1. Let _options_ be ! ObjectCreate(*null*).
        1. Else
          1. Let _options_ be ? ToObject(_options_).
        1. Let _opt_ be a new Record.
        1. Let _language_ be ? GetOption(_options_, `"language"`, `"string"`, *undefined*, *undefined*).
        1. If _language_ is not *undefined*, then
          1. If _language_ does not match the `language` production, throw a *RangeError* exception.
          1. If _language_ matches the `grandfathered` production, throw a *RangeError* exception.
        1. Set _opt_.[[Language]] to _language_.
        1. Let _script_ be ? GetOption(_options_, `"script"`, `"string"`, *undefined*, *undefined*).
        1. If _script_ is not *undefined*, then
          1. If _script_ does not match the `script` production, throw a *RangeError* exception.
        1. Set _opt_.[[Script]] to _script.
        1. Let _region_ be ? GetOption(_options_, `"region"`, `"string"`, *undefined*, *undefined*).
        1. If _region_ is not *undefined*, then
          1. If _region_ does not match the `region` production, throw a *RangeError* exception.
        1. Set _opt_.[[Region]] to _region_.
        1. Let _calendar_ be ? GetOption(_options_, `"calendar"`, `"string"`, *undefined*, *undefined*).
        1. If _calendar_ is not *undefined*, then
          1. If _calendar_ does not match the `[(3*8alphanum) *("-" (3*8alphanum))]` sequence, throw a *RangeError* exception.
        1. Set _opt_.[[ca]] to _calendar_.
        1. Let _collation_ be ? GetOption(_options_, `"collation"`, `"string"`, *undefined*, *undefined*).
        1. If _collation_ is not *undefined*, then
          1. If _collation_ does not match the `[(3*8alphanum) *("-" (3*8alphanum))]` sequence, throw a *RangeError* exception.
        1. Set _opt_.[[co]] to _collation_.
        1. Let _hc_ be ? GetOption(_options_, `"hourCycle"`, `"string"`, &laquo; `"h11"`, `"h12"`, `"h23"`, `"h24"` &raquo;, *undefined*).
        1. Set _opt_.[[hc]] to _hc_.
        1. Let _kf_ be ? GetOption(_options_, `"caseFirst"`, `"string"`, &laquo; `"upper"`, `"lower"`, `"false"` &raquo;, *undefined*).
        1. Set _opt_.[[kf]] to _kf_.
        1. Let _kn_ be ? GetOption(_options_, `"numeric"`, `"boolean"`, *undefined*, *undefined*).
        1. If _kn_ is not *undefined*, set _kn_ to ! ToString(_kn_).
        1. Set _opt_.[[kn]] to _kn_.
        1. Let _numberingSystem_ be ? GetOption(_options_, `"numberingSystem"`, `"string"`, *undefined*, *undefined*).
        1. If _numberingSystem_ is not *undefined*, then
          1. If _numberingSystem_ does not match the `[(3*8alphanum) *("-" (3*8alphanum))]` sequence, throw a *RangeError* exception.
        1. Set _opt_.[[nu]] to _numberingSystem_.
        1. Return ? CreateLocale(_tag_, _opt_, _proto_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-intl-locale-constructor">
    <h1>Properties of the Intl.Locale Constructor</h1>

    <p>
      The Intl.Locale constructor has the following properties:
    </p>

    <emu-clause id="sec-Intl.Locale.prototype">
      <h1>Intl.Locale.prototype</h1>

      <p>
        The value of *Intl.Locale.prototype* is *%LocalePrototype%*.
      </p>
      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.
      </p>
    </emu-clause>

    <emu-clause id="sec-intl.locale-internal-slots">
      <h1>Internal slots</h1>

      <p>
        The value of the [[RelevantExtensionKeys]] internal slot is &laquo; `"ca"`, `"co"`, `"hc"`, `"kf"`, `"kn"`, `"nu"` &raquo;. If %Collator%.[[RelevantExtensionKeys]] does not contain `"kf"`, then remove `"kf"` from %Locale%.[[RelevantExtensionKeys]]. If %Collator%.[[RelevantExtensionKeys]] does not contain `"kn"`, then remove `"kn"` from %Locale%.[[RelevantExtensionKeys]].
      </p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-intl-locale-prototype-object">
    <h1>Properties of the Intl.Locale Prototype Object</h1>

    <p>
      The Intl.Locale prototype object is itself an ordinary object. %LocalePrototype% is not an Intl.Locale instance and does not have an [[InitializedLocale]] internal slot or any of the other internal slots of Intl.Locale instance objects.
    </p>

    <emu-clause id="sec-Intl.Locale.prototype.constructor">
      <h1>Intl.Locale.prototype.constructor</h1>

      <p>
        The initial value of *Intl.Locale.prototype.constructor* is *%Locale%*.
      </p>
    </emu-clause>

    <emu-clause id="sec-Intl.Locale.prototype-@@tostringtag">
      <h1>Intl.Locale.prototype[ @@toStringTag ]</h1>

      <p>
        The initial value of the @@toStringTag property is the string value `"Intl.Locale"`.
      </p>

      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
      </p>
    </emu-clause>

    <emu-clause id="sec-Intl.Locale.prototype.maximize">
      <h1>Intl.Locale.prototype.maximize ()</h1>

      <emu-alg>
      1. Let _loc_ be the *this* value.
      1. If Type(_loc_) is not Object or _loc_ does not have an [[InitializedLocale]] internal slot, then
        1. Throw a *TypeError* exception.
      1. Let _maximal_ be the result of the <a href="https://www.unicode.org/reports/tr35/#Likely_Subtags">Add Likely Subtags</a> algorithm applied to _loc_.[[Locale]].
      1. Return ! CreateLocale(_maximal_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-Intl.Locale.prototype.minimize">
      <h1>Intl.Locale.prototype.minimize ()</h1>

      <emu-alg>
      1. Let _loc_ be the *this* value.
      1. If Type(_loc_) is not Object or _loc_ does not have an [[InitializedLocale]] internal slot, then
        1. Throw a *TypeError* exception.
      1. Let _minimal_ be the result of the <a href="https://www.unicode.org/reports/tr35/#Likely_Subtags">Remove Likely Subtags</a> algorithm applied to _loc_.[[Locale]].
      1. Return ! CreateLocale(_minimal_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-Intl.Locale.prototype.toString">
      <h1>Intl.Locale.prototype.toString ()</h1>

      <emu-alg>
      1. Let _loc_ be the *this* value.
      1. If Type(_loc_) is not Object or _loc_ does not have an [[InitializedLocale]] internal slot, then
        1. Throw a *TypeError* exception.
      1. Return _loc_.[[Locale]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-Intl.Locale.prototype.baseName">
      <h1>get Intl.Locale.prototype.baseName</h1>
      <p>`Intl.Locale.prototype.baseName` is an accessor property whose set accessor function is *undefined*. The following algorithm refers to <a href="https://tools.ietf.org/html/rfc5646#section-2.1">RFC 5646's Language-Tag grammar</a>. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _loc_ be the *this* value.
        1. If Type(_loc_) is not Object or _loc_ does not have an [[InitializedLocale]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Let _locale_ be _loc_.[[Locale]].
        1. Return _locale_.[[BaseName]].
    </emu-clause>

    <emu-clause id="sec-Intl.Locale.prototype.calendar">
      <h1>get Intl.Locale.prototype.calendar</h1>
      <p>`Intl.Locale.prototype.calendar` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _loc_ be the *this* value.
        1. If Type(_loc_) is not Object or _loc_ does not have an [[InitializedLocale]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Return _loc_.[[ca]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-Intl.Locale.prototype.collation">
      <h1>get Intl.Locale.prototype.collation</h1>
      <p>`Intl.Locale.prototype.collation` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _loc_ be the *this* value.
        1. If Type(_loc_) is not Object or _loc_ does not have an [[InitializedLocale]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Return _loc_.[[co]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-Intl.Locale.prototype.hourCycle">
      <h1>get Intl.Locale.prototype.hourCycle</h1>
      <p>`Intl.Locale.prototype.hourCycle` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _loc_ be the *this* value.
        1. If Type(_loc_) is not Object or _loc_ does not have an [[InitializedLocale]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Return _loc_.[[hc]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-Intl.Locale.prototype.caseFirst">
      <h1>get Intl.Locale.prototype.caseFirst</h1>
      <p>This property only exists if %Locale%.[[RelevantExtensionKeys]] contains `"kf"`.</p>
      <p>`Intl.Locale.prototype.caseFirst` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _loc_ be the *this* value.
        1. If Type(_loc_) is not Object or _loc_ does not have an [[InitializedLocale]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Return _loc_.[[kf]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-Intl.Locale.prototype.numeric">
      <h1>get Intl.Locale.prototype.numeric</h1>
      <p>This property only exists if %Locale%.[[RelevantExtensionKeys]] contains `"kn"`.</p>
      <p>`Intl.Locale.prototype.numeric` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _loc_ be the *this* value.
        1. If Type(_loc_) is not Object or _loc_ does not have an [[InitializedLocale]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Return _loc_.[[kn]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-Intl.Locale.prototype.numberingSystem">
      <h1>get Intl.Locale.prototype.numberingSystem</h1>
      <p>`Intl.Locale.prototype.numberingSystem` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _loc_ be the *this* value.
        1. If Type(_loc_) is not Object or _loc_ does not have an [[InitializedLocale]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Return _loc_.[[nu]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-Intl.Locale.prototype.language">
      <h1>get Intl.Locale.prototype.language</h1>
      <p>`Intl.Locale.prototype.language` is an accessor property whose set accessor function is *undefined*. The following algorithm refers to <a href="https://tools.ietf.org/html/rfc5646#section-2.1">RFC 5646's Language-Tag grammar</a>. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _loc_ be the *this* value.
        1. If Type(_loc_) is not Object or _loc_ does not have an [[InitializedLocale]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Let _locale_ be _loc_.[[Locale]].
        1. If _locale_ matches the `privateuse` or the `grandfathered` production, return *undefined*.
        1. Assert: _locale_ matches the `langtag` production.
        1. Return the substring of _locale_ corresponding to the `language` production.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-Intl.Locale.prototype.script">
      <h1>get Intl.Locale.prototype.script</h1>
      <p>`Intl.Locale.prototype.script` is an accessor property whose set accessor function is *undefined*. The following algorithm refers to <a href="https://tools.ietf.org/html/rfc5646#section-2.1">RFC 5646's Language-Tag grammar</a>. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _loc_ be the *this* value.
        1. If Type(_loc_) is not Object or _loc_ does not have an [[InitializedLocale]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Let _locale_ be _loc_.[[Locale]].
        1. If _locale_ matches the `privateuse` or the `grandfathered` production, return *undefined*.
        1. Assert: _locale_ matches the `langtag` production.
        1. If _locale_ does not contain the `["-" script]` sequence, return *undefined*.
        1. Return the substring of _locale_ corresponding to the `script` production.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-Intl.Locale.prototype.region">
      <h1>get Intl.Locale.prototype.region</h1>
      <p>`Intl.Locale.prototype.region` is an accessor property whose set accessor function is *undefined*. The following algorithm refers to <a href="https://tools.ietf.org/html/rfc5646#section-2.1">RFC 5646's Language-Tag grammar</a>. Its get accessor function performs the following steps:</p>
      <emu-alg>
        1. Let _loc_ be the *this* value.
        1. If Type(_loc_) is not Object or _loc_ does not have an [[InitializedLocale]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Let _locale_ be _loc_.[[Locale]].
        1. If _locale_ matches the `privateuse` or the `grandfathered` production, return *undefined*.
        1. Assert: _locale_ matches the `langtag` production.
        1. If _locale_ does not contain the `["-" region]` sequence, return *undefined*.
        1. Return the substring of _locale_ corresponding to the `region` production.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-locale-modified-algorithms">
  <h1>Modified algorithms</h1>

    <emu-clause id="sec-canonicalizelocalelist" aoid="CanonicalizeLocaleList">
      <h1>CanonicalizeLocaleList ( _locales_ )</h1>

      <p>
        The abstract operation CanonicalizeLocaleList takes the following steps:
      </p>

      <emu-alg>
        1. If _locales_ is *undefined*, then
          1. Return a new empty List.
        1. Let _seen_ be a new empty List.
        1. If Type(_locales_) is String, then
          1. Let _O_ be CreateArrayFromList(&laquo; _locales_ &raquo;).
        1. Else,
          1. Let _O_ be ? ToObject(_locales_).
        1. Let _len_ be ? ToLength(? Get(_O_, `"length"`)).
        1. Let _k_ be 0.
        1. Repeat, while _k_ &lt; _len_
          1. Let _Pk_ be ToString(_k_).
          1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).
          1. If _kPresent_ is *true*, then
            1. Let _kValue_ be ? Get(_O_, _Pk_).
            1. If Type(_kValue_) is not String or Object, throw a *TypeError* exception.
            1. <del>Let _tag_ be ? ToString(_kValue_).</del>
            1. <del>If IsStructurallyValidLanguageTag(_tag_) is *false*, throw a *RangeError* exception.</del>
            1. <del>Let _canonicalizedTag_ be CanonicalizeLanguageTag(_tag_).</del>
            1. <ins>If Type(_kValue_) is Object and _kValue_ has an [[InitializedLocale]] internal slot, then</ins>
              1. <ins>Let _locale_ be _kValue_.</ins>
            1. <ins>Else,</ins>
              1. <ins>Let _locale_ be ? CreateLocale(_kValue_).</ins>
            1. <del>If _canonicalizedTag_ is not an element of _seen_, append _canonicalizedTag_ as the last element of _seen_.</del>
            1. <ins>If, for each element _s_ of _seen_, ! SameValue(_s_.[[Locale]], _locale_.[[Locale]]) is *false*,</ins>
              1. <ins>Append _locale as the last element of _seen_.</ins>
          1. Increase _k_ by 1.
        1. Return _seen_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-resolvelocale" aoid="ResolveLocale">
      <h1>ResolveLocale ( _availableLocales_, _requestedLocales_, _options_, _relevantExtensionKeys_, _localeData_ )</h1>

      <p>
        The ResolveLocale abstract operation compares a BCP 47 language priority list _requestedLocales_ against the locales in _availableLocales_ and determines the best available language to meet the request. _availableLocales_, _requestedLocales_, and _relevantExtensionKeys_ must be provided as List values, _options_ and _localeData_ as Records.
      </p>

      <p>
        The following steps are taken:
      </p>

      <emu-alg>
        1. Let _matcher_ be _options_.[[localeMatcher]].
        1. If _matcher_ is `"lookup"`, then
          1. Let _r_ be LookupMatcher(_availableLocales_, _requestedLocales_).
        1. Else,
          1. Let _r_ be BestFitMatcher(_availableLocales_, _requestedLocales_).
        1. Let _baseName_ be _r_.[[BaseName]].
        1. Let _locale_ be _r_.[[Locale]].
        1. Let _result_ be a new Record.
        1. Let _displayOpts_ be a new Record.
        1. For each element _key_ of _relevantExtensionKeys_ in List order, do
          1. Let _foundLocaleData_ be _localeData_.[[&lt;_base_.[[BaseName]]&gt;]].
          1. Assert: Type(_foundLocaleData_) is Record.
          1. Let _keyLocaleData_ be _foundLocaleData_.[[&lt;_key_&gt;]].
          1. Assert: Type(_keyLocaleData_) is List.
          1. Let _value_ be _keyLocaleData_[0].
          1. Assert: Type(_value_) is either String or Null.
          1. Let _value_ be *undefined*.
          1. Let _displayValue_ be *undefined*.
          1. If _keyLocaleData_ contains a field _options_.[[&lt;_key_&gt;]],
            1. Let _value_ be _options_.[[&lt;_key_&gt;]].
            1. If ! SameValue(_value_, _locale_.[[&lt;_key_&gt;]]) is *true*,
              1. Let _displayValue_ be _value_.
            1. Otherwise,
              1. Let _displayValue_ be *undefined*.
          1. Otherwise, if _keyLocaleData_ contains a field _locale_.[[&lt;_key_&gt;]],
            1. Let _value_ be _locale_.[[&lt;_key_&gt;]].
            1. Let _displayValue_ be _value_.
          1. Otherwise, if _locale_.[[&lt;_key_&gt;]] is the empty string and _keyLocaleData_ contains `"true"`,
            1. Let _value_ be `"true"`.
            1. Let _displayValue_ be *undefined*.
          1. Otherwise,
            1. Let _value_ be _keyLocaleData_.[[0]].
            1. Let _displayValue_ be *undefined*.
          1. Set _result_.[[&lt;_key_&gt;]] to _value_.
          1. Set _displayOpts_.[[&lt;_key_&gt;]] to _displayValue_.
        1. Set _result_.[[locale]] to ! CreateLocale(_baseName_, _displayOpts_).[[Locale]].
        1. Return _result_.
      </emu-alg>

      <emu-note>
        Non-normative summary: Two algorithms are available to match the locales: the Lookup algorithm described in RFC 4647 section 3.4, and an implementation dependent best-fit algorithm. Independent of the locale matching algorithm, options specified through Unicode locale extension sequences are negotiated separately, taking the caller's relevant extension keys and locale data as well as client-provided options into consideration. The abstract operation returns a record with a [[locale]] field whose value is the language tag of the selected locale, and fields for each key in _relevantExtensionKeys_ providing the selected value for that key.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-lookupmatcher" aoid="LookupMatcher">
      <h1>LookupMatcher ( _availableLocales_, _requestedLocales_ )</h1>

      <p>
        The LookupMatcher abstract operation compares _requestedLocales_, which must be a List as returned by CanonicalizeLocaleList, against the locales in _availableLocales_ and determines the best available language to meet the request. The following steps are taken:
      </p>

      <emu-alg>
        1. Let _result_ be a new Record.
        1. For each element _locale_ of _requestedLocales_ in List order, do
          1. <del>Let _noExtensionsLocale_ be the String value that is _locale_ with all Unicode locale extension sequences removed.</del>
          1. Let _availableLocale_ be BestAvailableLocale(_availableLocales_, <del>_noExtensionsLocale_</del><ins>_locale_.[[BaseName]]</ins>).
          1. If _availableLocale_ is not *undefined*, then
            1. <del>Set _result_.[[locale]] to _availableLocale_.</del>
            1. <del>If _locale_ and _noExtensionsLocale_ are not the same String value, then</del>
              1. <del>Let _extension_ be the String value consisting of the first substring of _locale_ that is a Unicode locale extension sequence.</del>
              1. <del>Set _result_.[[extension]] to _extension_.</del>
            1. <del>Return _result_.</del>
            1. <ins>Return { [[Locale]]: _locale_, [[BaseName]]: _availableLocale_ }.</ins>
        1. Let _defLocale_ be DefaultLocale().
        1. <del>Set _result_.[[locale]] to _defLocale_.</del>
        1. <del>Return _result_.</del>
        1. <ins>Return { [[Locale]]: _defLocale_, [[BaseName]]: _defLocale_.[[BaseName]] }.</ins>
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-defaultlocale" aoid="DefaultLocale">
      <h1>DefaultLocale ()</h1>

      <p>
        The DefaultLocale abstract operation returns a <del>String value</del><ins>%Locale% instance</ins> representing the structurally valid (<emu-xref href="#sec-isstructurallyvalidlanguagetag"></emu-xref>) and  canonicalized (<emu-xref href="#sec-canonicalizelanguagetag"></emu-xref>) BCP 47 language tag for the host environment's current locale.
      </p>
    </emu-clause>

</emu-clause>
